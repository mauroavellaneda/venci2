"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cypressInitGeneratorInternal = exports.cypressInitGenerator = void 0;
const devkit_1 = require("@nx/devkit");
const update_package_scripts_1 = require("@nx/devkit/src/utils/update-package-scripts");
const plugin_1 = require("../../plugins/plugin");
const versions_1 = require("../../utils/versions");
function setupE2ETargetDefaults(tree) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    if (!nxJson.namedInputs) {
        return;
    }
    // E2e targets depend on all their project's sources + production sources of dependencies
    nxJson.targetDefaults ??= {};
    const productionFileSet = !!nxJson.namedInputs?.production;
    nxJson.targetDefaults.e2e ??= {};
    nxJson.targetDefaults.e2e.cache ??= true;
    nxJson.targetDefaults.e2e.inputs ??= [
        'default',
        productionFileSet ? '^production' : '^default',
    ];
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
function updateDependencies(tree, options) {
    const tasks = [];
    tasks.push((0, devkit_1.removeDependenciesFromPackageJson)(tree, ['@nx/cypress'], []));
    tasks.push((0, devkit_1.addDependenciesToPackageJson)(tree, {}, {
        ['@nx/cypress']: versions_1.nxVersion,
        cypress: versions_1.cypressVersion,
    }, undefined, options.keepExistingVersions));
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
function addPlugin(tree) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    nxJson.plugins ??= [];
    for (const plugin of nxJson.plugins) {
        if (typeof plugin === 'string'
            ? plugin === '@nx/cypress/plugin'
            : plugin.plugin === '@nx/cypress/plugin') {
            return;
        }
    }
    nxJson.plugins.push({
        plugin: '@nx/cypress/plugin',
        options: {
            targetName: 'e2e',
            componentTestingTargetName: 'component-test',
        },
    });
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
function updateProductionFileset(tree) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    const productionFileset = nxJson.namedInputs?.production;
    if (productionFileset) {
        nxJson.namedInputs.production = Array.from(new Set([
            ...productionFileset,
            '!{projectRoot}/cypress/**/*',
            '!{projectRoot}/**/*.cy.[jt]s?(x)',
            '!{projectRoot}/cypress.config.[jt]s',
        ]));
    }
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
async function cypressInitGenerator(tree, options) {
    return cypressInitGeneratorInternal(tree, { addPlugin: false, ...options });
}
exports.cypressInitGenerator = cypressInitGenerator;
async function cypressInitGeneratorInternal(tree, options) {
    updateProductionFileset(tree);
    options.addPlugin ??= process.env.NX_ADD_PLUGINS !== 'false';
    if (options.addPlugin) {
        addPlugin(tree);
    }
    else {
        setupE2ETargetDefaults(tree);
    }
    let installTask = () => { };
    if (!options.skipPackageJson) {
        installTask = updateDependencies(tree, options);
    }
    if (options.updatePackageScripts) {
        global.NX_CYPRESS_INIT_GENERATOR_RUNNING = true;
        await (0, update_package_scripts_1.updatePackageScripts)(tree, plugin_1.createNodes);
        global.NX_CYPRESS_INIT_GENERATOR_RUNNING = false;
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return installTask;
}
exports.cypressInitGeneratorInternal = cypressInitGeneratorInternal;
exports.default = cypressInitGenerator;
